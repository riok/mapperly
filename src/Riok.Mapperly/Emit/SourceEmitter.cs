using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Riok.Mapperly.Descriptors;
using Riok.Mapperly.Emit.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using static Riok.Mapperly.Emit.Syntax.SyntaxFactoryHelper;

namespace Riok.Mapperly.Emit;

public static class SourceEmitter
{
    private const string AutoGeneratedComment = "// <auto-generated />";

    public static CompilationUnitSyntax Build(MapperDescriptor descriptor, CancellationToken cancellationToken)
    {
        var ctx = new SourceEmitterContext(
            descriptor.Static,
            descriptor.NameBuilder,
            new SyntaxFactoryHelper(descriptor.SupportedFeatures),
            descriptor.AggressiveInliningTypes
        );
        var mapper = BuildMapper(ctx, descriptor, cancellationToken);

        var members = new List<MemberDeclarationSyntax>(descriptor.UnsafeAccessors?.Count ?? 0 + 1) { mapper };
        members.AddRange(descriptor.UnsafeAccessors?.Build(ctx, cancellationToken) ?? []);

        var memberSyntaxes = List(members.SeparateByTrailingLineFeed(ctx.SyntaxFactory.Indentation));
        return CompilationUnit()
            .WithMembers(memberSyntaxes)
            .WithLeadingTrivia(
                Comment(AutoGeneratedComment),
                ElasticCarriageReturnLineFeed,
                Nullable(true, !descriptor.SupportedFeatures.NullableAttributes),
                ElasticCarriageReturnLineFeed
            );
    }

    private static MemberDeclarationSyntax BuildMapper(
        SourceEmitterContext ctx,
        MapperDescriptor descriptor,
        CancellationToken cancellationToken
    )
    {
        ctx = IndentForMapper(ctx, descriptor.Symbol);
        var memberCtx = ctx.AddIndentation();
        var members = BuildMembers(memberCtx, descriptor, cancellationToken);
        members = members.SeparateByLineFeed(memberCtx.SyntaxFactory.Indentation);
        MemberDeclarationSyntax mapperDeclaration = ctx.SyntaxFactory.Class(
            descriptor.Symbol.Name,
            descriptor.Syntax.Modifiers,
            List(members)
        );

        mapperDeclaration = WrapInClassesAsNeeded(ref ctx, descriptor.Symbol, mapperDeclaration);
        mapperDeclaration = WrapInNamespaceIfNeeded(ref ctx, descriptor.Namespace, mapperDeclaration);
        return mapperDeclaration;
    }

    private static IEnumerable<MemberDeclarationSyntax> BuildMembers(
        SourceEmitterContext ctx,
        MapperDescriptor descriptor,
        CancellationToken cancellationToken
    )
    {
        foreach (var mapping in descriptor.MethodMappings)
        {
            cancellationToken.ThrowIfCancellationRequested();
            yield return mapping.BuildMethod(ctx);
        }
    }

    private static MemberDeclarationSyntax WrapInClassesAsNeeded(
        ref SourceEmitterContext ctx,
        INamedTypeSymbol symbol,
        MemberDeclarationSyntax member
    )
    {
        var containingType = symbol.ContainingType;
        while (containingType != null)
        {
            if (containingType.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() is not TypeDeclarationSyntax containingTypeSyntax)
                break;

            ctx = ctx.RemoveIndentation();
            member = ctx.SyntaxFactory.TypeDeclaration(containingTypeSyntax, SingletonList(member));
            containingType = containingType.ContainingType;
        }

        return member;
    }

    private static MemberDeclarationSyntax WrapInNamespaceIfNeeded(
        ref SourceEmitterContext ctx,
        string? namespaceName,
        MemberDeclarationSyntax member
    )
    {
        if (namespaceName == null)
        {
            return member;
        }

        ctx = ctx.RemoveIndentation();
        return ctx.SyntaxFactory.Namespace(namespaceName).WithMembers(SingletonList(member));
    }

    private static SourceEmitterContext IndentForMapper(SourceEmitterContext ctx, INamedTypeSymbol symbol)
    {
        while (symbol.ContainingType != null)
        {
            ctx = ctx.AddIndentation();
            symbol = symbol.ContainingType;
        }

        return symbol.ContainingNamespace.ContainingNamespace == null ? ctx : ctx.AddIndentation();
    }
}
