---
sidebar_position: 4
description: Map constant and generated values
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Constant and generated values

## Constant values

To map a constant value to a member or a constructor parameter `MapValue` can be used.
Make sure the value exactly matches the target type.

<!-- prettier-ignore-start -->
<!-- prettier formatting breaks the code block -->
<Tabs>
  <TabItem value="declaration" label="Declaration" default>
      ```csharp
      [MapValue(nameof(CarDto.SourceSystem), "C1")]
      public partial CarDto Map(Car car);
      ```
  </TabItem>
  <TabItem value="generated" label="Generated code" default>
      ```csharp
      target.SourceSystem = "C1";
      ```
  </TabItem>
</Tabs>
<!-- prettier-ignore-end -->

## Method generated values

To map a method generated value to a member or a constructor parameter `MapValue` can be used.
Make sure the return type exactly matches the target type.

<Tabs>
    <TabItem value="declaration" label="Declaration" default>
        ```csharp
        [MapValue(nameof(CarDto.SourceSystem), Use = nameof(GetSourceSystem))]
        public partial CarDto Map(Car car);

        string GetSourceSystem() => "C1";
        ```
    </TabItem>
    <TabItem value="generated" label="Generated code" default>
        ```csharp
        target.SourceSystem = GetSourceSystem();
        ```
    </TabItem>

</Tabs>

This also works for constructor parameters.

### Named mapping

The name of the value generator can be overriden by the `NamedMapping` attribute:

```csharp
[MapValue(nameof(CarDto.SourceSystem), Use = "CustomGetSourceSystem")]
public partial CarDto Map(Car car);

[NamedMapping("CustomGetSourceSystem")]
string GetSourceSystem() => "C1";
```

### External method reference

It is also possible to reference methods which are outside the mapper class. To do this, prefix the path with `@` in the `Use` property.
Alternatively, you can also string reference of the type. In this case the type must be fully qualified.

<Tabs>
    <TabItem value="use-full-nameof" label="Use with fullnameof" default>
        ```csharp
        using OtherNamespace;

        namespace MyNamespace;

        [Mapper]
        public partial class CarMapper
        {
            // highlight-start
            [MapValue(nameof(CarDto.SourceSystem), Use = nameof(@SourceSystems.GetSourceSystem))]
            // highlight-end
            public partial CarDto Map(Car car);

            // generates
            target.SourceSystem = global::OtherNamespace.SourceSystems.GetSourceSystem();
        }
        ```

        ```csharp
        namespace OtherNamespace;

        public static class SourceSystems
        {
            public static string GetSourceSystem() => "C1";
        }
        ```

    </TabItem>

    <TabItem value="use-with-string-path" label="Use with string path">
        ```csharp
        namespace MyNamespace;

        [Mapper]
        public partial class CarMapper
        {
            // highlight-start
            [MapValue(nameof(CarDto.SourceSystem), Use = "OtherNamespace.SourceSystems.GetSourceSystem")]
            // highlight-end
            public partial CarDto Map(Car car);

            // generates
            target.SourceSystem = global::OtherNamespace.SourceSystems.GetSourceSystem();
        }
        ```

        ```csharp
        namespace OtherNamespace;

        public static class SourceSystems
        {
            public static string GetSourceSystem() => "C1";
        }
        ```

    </TabItem>

</Tabs>

With this syntax, you can also use instance methods if the mapper class has a property or field referencing the external type.
In this case, the method should be referenced through this member with the `@` prefix or use string reference.

<Tabs>
    <TabItem value="instance-with-fullnameof" label="Instance with fullnameof" default>
        ```csharp
        [Mapper]
        public partial class CarMapper
        {
            // highlight-start
            public SourceSystems SourceSystems { get; } = new();
            // highlight-end

            // highlight-start
            [MapValue(nameof(CarDto.SourceSystem), Use = nameof(@SourceSystems.GetSourceSystem))]
            // highlight-end
            public partial CarDto Map(Car car);

            // generates
            target.SourceSystem = SourceSystems.GetSourceSystem();
        }

        public class SourceSystems
        {
            public string GetSourceSystem() => "C1";
        }
        ```

    </TabItem>

    <TabItem value="instance-with-string-path" label="Instance with string path">
        ```csharp
        [Mapper]
        public partial class CarMapper
        {
            // highlight-start
            public SourceSystems SourceSystems { get; } = new();
            // highlight-end

            // highlight-start
            [MapValue(nameof(CarDto.SourceSystem), Use = "SourceSystems.GetSourceSystem")]
            // highlight-end
            public partial CarDto Map(Car car);

            // generates
            target.SourceSystem = _sourceSystems.GetSourceSystem();
        }

        public class SourceSystems
        {
            public string GetSourceSystem() => "C1";
        }
        ```

    </TabItem>

</Tabs>

The `NamedMapping` attribute can also be used in combination with the external method reference.

```csharp
namespace MyNamespace;

[Mapper]
public partial class CarMapper
{
    // highlight-start
    [MapValue(nameof(CarDto.SourceSystem), Use = "OtherNamespace.SourceSystems.CustomGetSourceSystem")]
    // highlight-end
    public partial CarDto Map(Car car);

    // generates
    target.SourceSystem = global::OtherNamespace.SourceSystems.GetSourceSystem();
}
```

```csharp
namespace OtherNamespace;

public static class SourceSystems
{
    [NamedMapping("CustomGetSourceSystem")]
    public static string GetSourceSystem() => "C1";
}
```
