---
sidebar_position: -5
description: How to upgrade to Mapperly 5.0 and a list of all its breaking changes
---

# v5.0

[![Release notes 5.0.0](https://img.shields.io/badge/Release_notes-v5.0-green?style=flat-square)](https://github.com/riok/mapperly/releases/tag/v5.0.0)
[![NuGet v5.0.0](https://img.shields.io/badge/NuGet-v5.0-blue?style=flat-square)](https://www.nuget.org/packages/Riok.Mapperly/5.0.0)

## Migration guide from v4.3.1

- Only .NET Framework 4.8 and .NET 8.0 and later versions are supported. Earlier .NET versions may still work with new Roslyn compiler SDKs but are not tested.
- Mapperly now respects `IFormatProvider` overloads when mapping using `Parse` methods.
- The fullnameof feature does not apply automatically to three-segment paths.
- Default enabled conversions no longer include explicit casts, see below.

## Default enabled conversions exclude explicit casts

Starting with v5.0, the default value for `MapperAttribute.EnabledConversions` has been changed from `MappingConversionType.All` to the new `MappingConversionType.Default`.
`MappingConversionType.Default` includes all safe conversions but excludes explicit casts.

Explicit casts are excluded by default because they can lead to precision loss.
For example, mapping a `long` property to an `int` property or a `double` to an `int` now requires explicit configuration or a manual mapping implementation.

If your project relies on explicit casts, you have several options:

### Implement manual mappings (recommended)

The safest approach is to manually implement the mapping for properties that require an explicit cast. This forces you to handle potential data loss or exceptions explicitly.

```csharp
[Mapper]
public partial class MyMapper
{
    [MapProperty(nameof(Source.Value), nameof(Target.Value), Use = nameof(MapLongToInt))]
    public partial Target Map(Source source);

    private int MapLongToInt(long value) => (int)value;
}
```

### Enable explicit casts

If you want to allow explicit casts, you can enable them by adding `MappingConversionType.ExplicitCast` to the `EnabledConversions`.

**Per Mapper:**

```csharp
[Mapper(EnabledConversions = MappingConversionType.Default | MappingConversionType.ExplicitCast)]
public partial class MyMapper
{
    // ...
}
```

**Globally (using `MapperDefaults`):**

```csharp
[assembly: MapperDefaults(EnabledConversions = MappingConversionType.Default | MappingConversionType.ExplicitCast)]
```

### Restore previous behavior (quick fix)

To restore the exact behavior of previous Mapperly releases, you can set `EnabledConversions` to `MappingConversionType.All`.

```csharp
// globally
[assembly: MapperDefaults(EnabledConversions = MappingConversionType.All)]
// per mapper
[Mapper(EnabledConversions = MappingConversionType.All)]
public partial class MyMapper
{
    // ...
}
```

See also the [conversions documentation](../configuration/conversions.md).

## `fullnameof` fix

In previous versions, the `fullnameof` feature was accidentally applied automatically to three-segment paths, even without the `@` prefix.
This behavior has been corrected, and the `@` prefix is now required to enable the feature.

To migrate, review your codebase and ensure that all three-segment paths are prefixed with `@` if the full name is expected (instead of just the last segment).

Example:

```csharp
[MapProperty(nameof(Car.Make.Id), nameof(CarDto.MakeId))]
```

In previous versions this resulted in:

```csharp
[MapProperty("Make.Id", "MakeId")]
```

In v5.0 this will result in:

```csharp
[MapProperty("Id", "MakeId")]
```

Unless `fullnameof` is applied:

```csharp
[MapProperty(nameof(@Car.Make.Id), nameof(CarDto.MakeId))]
```

Which will result in:

```csharp
[MapProperty("Make.Id", "MakeId")]
```

See also the [full-nameof documentation](../configuration/full-nameof.md).
