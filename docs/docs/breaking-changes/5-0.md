---
sidebar_position: -5
description: How to upgrade to Mapperly 5.0 and a list of all its breaking changes
---

# v5.0

[![Release notes 5.0.0](https://img.shields.io/badge/Release_notes-v5.0-green?style=flat-square)](https://github.com/riok/mapperly/releases/tag/v5.0.0)
[![NuGet v5.0.0](https://img.shields.io/badge/NuGet-v5.0-blue?style=flat-square)](https://www.nuget.org/packages/Riok.Mapperly/5.0.0)

## Migration guide from v4.3.1

- Only .NET Framework 4.8 and .NET 8.0 and later versions are supported. Earlier .NET versions may still work with new Roslyn compiler SDKs but are not tested.
- Mapperly now respects `IFormatProvider` overloads when mapping using `Parse` methods.
- The fullnameof feature does not apply automatically to three-segment paths.
- Default enabled conversions no longer include explicit casts, see below.
- `Stack<T>` deep cloning now preserves the order of elements by default.
- Inaccessible members from other assemblies are now included in the mapping process if `IncludedMembers` or `IncludedConstructors` options are configured to include them.

## Inaccessible members from other assemblies included

Previously, private, protected, or internal members from other assemblies were ignored, even if `IncludedMembers` or `IncludedConstructors` were configured to include them.
Starting with v5.0, these members are now included in the mapping process if the configuration allows it.

This may lead to compilation errors if you have configured `IncludedMembers` to `MemberVisibility.All` but have not handled the newly discovered members.
Ignore these members to restore the previous behavior.

## `Stack<T>` deep cloning order

When deep cloning a `Stack<T>`, Mapperly now preserves the order of elements by default.
Previously, the order was reversed (due to the behavior of the `Stack<T>(IEnumerable<T>)` constructor).

To restore the previous behavior, set `StackCloningStrategy` to `StackCloningStrategy.ReverseOrder`:

```csharp
[assembly: MapperDefaults(StackCloningStrategy = StackCloningStrategy.ReverseOrder)]
// or
[Mapper(UseDeepCloning = true, StackCloningStrategy = StackCloningStrategy.ReverseOrder)]
public partial class MyMapper
{
    // ...
}
```

## Default enabled conversions exclude explicit casts

Starting with v5.0, the default value for `MapperAttribute.EnabledConversions` has been changed from `MappingConversionType.All` to the new `MappingConversionType.Default`.
`MappingConversionType.Default` includes all safe conversions but excludes explicit casts.

Explicit casts are excluded by default because they can lead to precision loss.
For example, mapping a `long` property to an `int` property or a `double` to an `int` now requires explicit configuration or a manual mapping implementation.

If your project relies on explicit casts, you have several options:

### Implement manual mappings (recommended)

The safest approach is to manually implement the mapping for properties that require an explicit cast. This forces you to handle potential data loss or exceptions explicitly.

```csharp
[Mapper]
public partial class MyMapper
{
    [MapProperty(nameof(Source.Value), nameof(Target.Value), Use = nameof(MapLongToInt))]
    public partial Target Map(Source source);

    private int MapLongToInt(long value) => (int)value;
}
```

### Enable explicit casts

If you want to allow explicit casts, you can enable them by adding `MappingConversionType.ExplicitCast` to the `EnabledConversions`.

**Per Mapper:**

```csharp
[Mapper(EnabledConversions = MappingConversionType.Default | MappingConversionType.ExplicitCast)]
public partial class MyMapper
{
    // ...
}
```

**Globally (using `MapperDefaults`):**

```csharp
[assembly: MapperDefaults(EnabledConversions = MappingConversionType.Default | MappingConversionType.ExplicitCast)]
```

### Restore previous behavior (quick fix)

To restore the exact behavior of previous Mapperly releases, you can set `EnabledConversions` to `MappingConversionType.All`.

```csharp
// globally
[assembly: MapperDefaults(EnabledConversions = MappingConversionType.All)]
// per mapper
[Mapper(EnabledConversions = MappingConversionType.All)]
public partial class MyMapper
{
    // ...
}
```

See also the [conversions documentation](../configuration/conversions.md).

## `fullnameof` fix

In previous versions, the `fullnameof` feature was accidentally applied automatically to three-segment paths, even without the `@` prefix.
This behavior has been corrected, and the `@` prefix is now required to enable the feature.

To migrate, review your codebase and ensure that all three-segment paths are prefixed with `@` if the full name is expected (instead of just the last segment).

Example:

```csharp
[MapProperty(nameof(Car.Make.Id), nameof(CarDto.MakeId))]
```

In previous versions this resulted in:

```csharp
[MapProperty("Make.Id", "MakeId")]
```

In v5.0 this will result in:

```csharp
[MapProperty("Id", "MakeId")]
```

Unless `fullnameof` is applied:

```csharp
[MapProperty(nameof(@Car.Make.Id), nameof(CarDto.MakeId))]
```

Which will result in:

```csharp
[MapProperty("Make.Id", "MakeId")]
```

See also the [full-nameof documentation](../configuration/full-nameof.md).
